**Kadane's Algorithm** খুব সহজভাবে একটি অ্যারের মধ্যে এমন একটি সাব-অ্যারে খুঁজে বের করে যার **যোগফল (sum)** সবচেয়ে বেশি। এটি একটি **greedy algorithm**, যেটি শুধু একবার লুপ চালিয়েই সমস্যার সমাধান করে।

### মূল ধারণা:

1. **"কোন সাব-অ্যারে শুরু করা উচিত?"**
    
    - যদি কোনো সাব-অ্যারের যোগফল নেগেটিভ হয়ে যায়, তাহলে সেটি ফেলে দিয়ে নতুন সাব-অ্যারে শুরু করা উচিত। কারণ নেগেটিভ যোগফল পরবর্তী সংখ্যাগুলোকে ছোট করে দেবে।

1. **"সর্বোচ্চ যোগফল ধরে রাখা"**
    
    - প্রত্যেক পজিশনে অ্যারের যোগফল আপডেট করার সময় চেক করা হয়, এখন পর্যন্ত সর্বোচ্চ যোগফল কী।
---

### ধাপে ধাপে কাজের প্রক্রিয়া:

ধরা যাক অ্যারে: `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

1. **শুরু থেকে `curr_sum` এবং `max_sum` সেট করা:**
    
    - `curr_sum` = 0 (বর্তমান যোগফল ট্র্যাক করে)
    - `max_sum` = -Infinity বা প্রথম উপাদান (সর্বোচ্চ যোগফল সংরক্ষণ করে)

1. **অ্যারের প্রতিটি উপাদান পরপর যোগ করা:**
    
    - যদি `curr_sum < 0` হয়, তাহলে `curr_sum` রিসেট করে নতুন সাব-অ্যারে শুরু করা হয়।
    - প্রতিটি ধাপে `max_sum` আপডেট করা হয়: `max_sum = Math.max(max_sum, curr_sum)`।

1. **লুপ শেষে `max_sum`-এ থাকবে সর্বোচ্চ যোগফল।**
    

---

### উদাহরণ দিয়ে ব্যাখ্যা:

|পদক্ষেপ|উপাদান (`nums[i]`)|`curr_sum` (চলমান যোগফল)|`max_sum` (সর্বোচ্চ যোগফল)|
|---|---|---|---|
|1|-2|-2|-2|
|2|1|1|1|
|3|-3|-2|1|
|4|4|4|4|
|5|-1|3|4|
|6|2|5|5|
|7|1|6|6|
|8|-5|1|6|
|9|4|5|6|

**ফলাফল:** সর্বোচ্চ সাব-অ্যারের যোগফল = `6` (অ্যারে `[4, -1, 2, 1]` থেকে)।