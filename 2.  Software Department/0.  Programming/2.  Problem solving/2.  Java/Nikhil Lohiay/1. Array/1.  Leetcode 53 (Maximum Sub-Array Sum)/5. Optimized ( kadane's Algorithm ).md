#### ধারণা: 
এই পদ্ধতিতে আমরা প্রতিটি উপাদানের জন্য **maximum sub-array sum** ধরে রাখবো। পরবর্তী উপাদান যুক্ত করে তা আপডেট করব।  
এই ধারণা এসেছে একটি গুরুত্বপূর্ণ পর্যবেক্ষণ থেকে:

1. প্রতিটি উপাদানের জন্য **contiguous sub-arrays** তৈরি করে সর্বাধিক **sum** খুঁজতে হয়।
2. যদি পূর্ববর্তী উপাদানের সর্বাধিক **sum** (যা **current maximum**) এর সাথে বর্তমান উপাদান যোগ করে, নতুন **sum** বড় হয়, তাহলে আমরা আপডেট করব।

#### ধাপসমূহ:
1. দুইটি ভেরিয়েবল শুরুতে ইনিশিয়ালাইজ করুন:
    - `max_sum` (এখন পর্যন্ত পাওয়া সর্বাধিক **sum**)
    - `curr_max` (বর্তমান উপাদানের জন্য সর্বাধিক **sum**)
2. প্রতিটি উপাদানের জন্য:
    - `curr_max` আপডেট করুন: `curr_max = max(curr_max + nums[i], nums[i])`
    - `max_sum` আপডেট করুন: `max_so_far = max(max_sum, curr_max)`
3. লুপ শেষে, max_sum হবে সর্বাধিক **sum**।

#### Code:
## Here is`my code` with respect to `Kadane's algorithm` : 

```java 
public static int kdns_algo(int[] nums ) {  
    int maximum_sum = nums[0] ;  
  
    int curr = nums[0] ;  
  
    for(int i = 0 ; i < nums.length ; i++ )  
    {  
        curr += nums[i];  
        if(curr < 0) curr = nums[0] ;  
        if(curr > maximum_sum ) maximum_sum = curr;  
  
    }  
  
	return  maximum_sum;  
}
```


## `GitHub` Code  with respect to `Kadane's algorithm` :  
আমার কোডে শেষ ধাপে `curr_sum = a[0]` এটা লুপ ঘুরে কাজ হচ্ছিল, কিন্তু GitHub-এর কোডে একই কাজটা লুপের বাইরে ইনিশিয়ালাইজ করা হয়েছে। আর তাই যেহেতু GitHub-এ তারা শেষের কাজ আগেই করেছে, আমার অ্যালগরিদম অনুযায়ী প্রথমের কাজ শেষে চলে গেছে এবং শেষের কাজ প্রথমেই চলে এসেছে।
আবার, শেষের কাজ তো চেক করা, কিন্তু যোগের কাজটা আবার প্রথমেই করা হয়েছে।  কারণ, আগে যোগ না করে তো আর চেক করা যাবে না। 
এজন্য একটা `max` ফাংশন কল করে সেখানে প্যারামিটার হিসেবে `max(curr_sum + a[i], a[i])` কম্পেয়ার করা হচ্ছে। 
অর্থাৎ এখানে দুই কাজ একসাথে করতে হচ্ছে, এই আর কি।


```java
public int maxSubArray(int[] nums) {

    // সর্বাধিক sum এবং বর্তমান sum ধারণ করার জন্য ভেরিয়েবল
    int max_sum = nums[0];
    int curr_max = nums[0];

    for (int i = 1; i < nums.length; i++) {

        // বর্তমান উপাদানের জন্য সর্বাধিক sum আপডেট করুন
        curr_max = Math.max(nums[i], nums[i] + curr_max);

        // এখন পর্যন্ত সর্বাধিক sum আপডেট করুন
        max_sum = Math.max(curr_max, max_so_far);
    }

    return max_sum;
}

```

#### Time Complexity:
- **O(n)**: শুধুমাত্র একবার array traverse করতে হয়।

#### Space Complexity:
- **O(1)**: কোনো অতিরিক্ত ডেটা স্ট্রাকচার ব্যবহার হয় না।


###  Code Behavior and Differences

1. **Initialization এর পার্থক্য**:
    
    - **আমার কোড**: `curr_sum` এর মান লুপের ভেতরে `curr_sum = a[0]` দিয়ে ইনিশিয়ালাইজ করা হয়েছে এবং ইটারেটিভভাবে আপডেট করা হয়েছে।
    - **GitHub কোড**: একই ইনিশিয়ালাইজেশন (`curr_sum = a[0]`) লুপের বাইরে করা হয়েছে, যার ফলে লজিক কিছুটা ভিন্ন।

1. **অপারেশনের ক্রমানুসার**:
    
    - GitHub কোডে, এমনভাবে লজিক সাজানো হয়েছে যে আমার কোডের শেষের কাজ তারা প্রথমেই করেছে। এই পুনর্বিন্যাসের ফলে কার্যপ্রক্রিয়ার ক্রম পাল্টে গেছে, কিন্তু ফলাফল একই।
    - এর ফলে, আমার অ্যালগরিদমের প্রথম কাজ শেষে চলে গেছে, আর শেষের কাজ প্রথমে চলে এসেছে।

1. **`max` ফাংশন দিয়ে দুই কাজ একসাথে**:
    
    - **কেন?** চেক করার আগে যোগের কাজটা করতেই হবে, কারণ নতুন মানের উপর ভিত্তি করেই চেক করা সম্ভব।
    - **কীভাবে?** এখানে `max` ফাংশন ব্যবহার করে দুটি মান কম্পেয়ার করা হচ্ছে:
        - `curr_sum + a[i]`: চলমান subarray এর যোগফল।
        - `a[i]`: শুধুমাত্র বর্তমান এলিমেন্ট দিয়ে নতুন subarray শুরু করার মান।
    - এর মাধ্যমে এক ধাপেই দুই কাজ করা হচ্ছে: যোগফল হিসাব করা এবং চলমান subarray চালিয়ে যাওয়া বা নতুন subarray শুরু করার সিদ্ধান্ত নেয়া।

### Key Insight:

`curr_sum` লুপের বাইরে ইনিশিয়ালাইজ করে এবং `max` ফাংশনের কার্যকর ব্যবহার করে, GitHub কোড অ্যালগরিদমটিকে আরও সংক্ষিপ্ত ও কার্যকর করেছে, যেখানে অপারেশনগুলি পরিষ্কার এবং সহজভাবে সাজানো হয়েছে।



#### এই পদ্ধতি কেন?
- এটি **efficient** কারণ এটি অতিরিক্ত sub-array তৈরি করে না।
- **Kadane’s Algorithm** মূলত **iterative** এবং প্রতিটি ধাপে পূর্ববর্তী তথ্য ব্যবহার করে কাজ করে।
- একে **Dynamic Programming**-এর একটি সরল ফর্মও বলা যেতে পারে।

---
### Code Explanation : 
- Videos:
	[Nikhil Lohiya](https://www.youtube.com/watch?v=GrNSGC8Z2T0&list=PLFdAYMIVJQHPlQ0vhbV6FVL-1dWNmJcYJ&index=2) 
	[Wrong Submission](https://www.youtube.com/watch?v=RXOGGqlxpIU)
	

### **কেন এইভাবে চিন্তা করলাম?**
1. **Brute Force**: সরাসরি পদ্ধতিতে কাজ শুরু করা।
2. **Optimized Approach**: আগের ফলাফলকে কাজে লাগিয়ে সময় বাঁচানো।
3. **Kadane’s Algorithm**: শুধুমাত্র গুরুত্বপূর্ণ তথ্য ধরে রেখে কার্যক্ষমতা বাড়ানো।

এটি দেখায় কীভাবে সমস্যার সরল সমাধান থেকে কার্যকর সমাধানের দিকে এগোনো যায়।