### শেল এবং কমান্ড লাইন ব্যবহার করে কমান্ড চালানো

**Bash** (`/bin/bash`) হল একটি অ্যাপ্লিকেশন এবং Oracle Linux-এ ডিফল্ট শেল। যখন টার্মিনাল খোলা হয়, Oracle Linux একটি প্রম্পট (`$`) প্রদান করে। আমরা কমান্ড সহজতর করার জন্য এবং এর গঠন ও আউটপুট পরিচালনার জন্য শেল মেটাচারেক্টার ব্যবহার করব। উদাহরণস্বরূপ, কমান্ড-লাইন ইতিহাস দেখতে এবং সেট করার জন্য ব্যবহার করা যাবে।

1. একটি টার্মিনাল খুলুন এবং SSH-এর মাধ্যমে `ol-node-01` ইনস্ট্যান্সে কানেক্ট করুন।

```shell
	ssh oracle@<ip_address_of_instance>
```
    
2. নিশ্চিত করুন যে ডিফল্ট শেল `/bin/bash` চলছে এবং `SHELL` ভেরিয়েবলের কন্টেন্ট প্রদর্শন করুন।
    
```shell
    echo $SHELL
```


    
3. `cd` কমান্ডের সাথে টিল্ড (`~`) মেটাচারেক্টার ব্যবহার করে হোম ডিরেক্টরিতে যান।

```shell
    cd ~
```
    
4. `history` কমান্ডে সংরক্ষিত বর্তমান কমান্ড লাইনের সংখ্যা চেক করুন।

```shell
	echo $HISTFILESIZE $HISTSIZE
```
    
5. `HISTSIZE`-এর মান ২০ সেট করুন।
    
```shell
	HISTSIZE=20
```
    
6. একটি ওপেন টার্মিনাল উইন্ডোর জন্য আপডেট করা কমান্ড-লাইন ইতিহাসের আকার নিশ্চিত করুন।
	 
```shell
	echo $HISTSIZE
```
    
7. `history` কমান্ডের পেজভিত্তিক আউটপুট দেখুন।

```shell
	history | less
```
    
8. পূর্ববর্তী কমান্ড থেকে বের হতে `q` কী চাপুন।
    
9. ইতিহাস ডাটাবেস থেকে আগের ১০টি কমান্ড দেখুন।
  
```shell
	history 10
```
    
10. পূর্ববর্তী ইতিহাস মুছে ফেলতে `–c` অপশন ব্যবহার করুন।

```shell
	history -c
```
    
11. মুছে ফেলা ইতিহাস দেখুন।

```shell
	history
```
    

---

### ফাইল এবং ডিরেক্টরি নিয়ে কাজ করুন

1. বর্তমান ওয়ার্কিং ডিরেক্টরি প্রদর্শন করুন।
```shell
	pwd
```
    
2. বর্তমান ডিরেক্টরির সব কন্টেন্টের একটি দীর্ঘ তালিকা দেখান।
   
```shell
	ls -la
```
    
3. বর্তমান ডিরেক্টরিতে ফাইলের ধরনগুলো দেখান।
    
```shell
	ls -Fa
```
    
4. একটি `temp` নামের ডিরেক্টরি তৈরি করুন (যদি ইতোমধ্যে না থাকে)।

```shell
	mkdir temp
```
    
5. `temp` ডিরেক্টরিতে যান।
    
```shell
	 cd temp
```
    
6. বর্তমান ওয়ার্কিং ডিরেক্টরি দেখান।

```shell
	pwd
```
    
7. Oracle Linux ফাইলসিস্টেমের মূল ডিরেক্টরির ফাইল এবং ডিরেক্টরিগুলো দেখুন।
    
```shell
ls /
```
    
8. আপনার হোম ডিরেক্টরিতে ফিরে যান।
  
```shell
cd ~
```
    
9. বর্তমান ডিরেক্টরির প্যারেন্ট ডিরেক্টরিতে যান।

```shell
cd ..
```
    
10. বর্তমান ওয়ার্কিং ডিরেক্টরি দেখান।

    
```shell
pwd
```
    
11. পূর্ববর্তী ডিরেক্টরিতে ফিরে যান।

```shell
cd -
```
    
12. `myfile` নামক একটি নতুন ফাইল তৈরি করুন যার কন্টেন্ট হবে `hello world`।
    
```shell
echo hello world > myfile
```
    
13. নতুন `myfile` ফাইল তৈরি হওয়া যাচাই করুন।
```shell
	 ls
```
    
14. `myfile` ফাইলের কন্টেন্ট দেখান।
   
```shell
cat myfile
```
    
15. `myfile` ফাইলটি আরেকটি নামে কপি করুন।
    

    `cp myfile myfile2`
    
16. বর্তমান ডিরেক্টরির কন্টেন্টের একটি দীর্ঘ তালিকা দেখান।
  
```shell
	ls -l
```
    
17. `myfile2` ফাইলের ধরন দেখান।
    
```shell
	file myfile2
```
    
18. `myfile2` ফাইলের কন্টেন্ট দেখান।
 
```shell
	cat myfile2
```
    
19. `myfile2` ফাইলটি `temp` ডিরেক্টরিতে কপি করুন।

```shell
	cp myfile2 temp/
```

যখন আপনি **`/` (ফরওয়ার্ড স্ল্যাশ)** ব্যবহার করেন, তখন এটি নির্দেশ করে যে **`mydir2`** একটি ডিরেক্টরি এবং আপনি কন্টেন্টকে সেই ডিরেক্টরির মধ্যে কপি করতে চান।

### ফরওয়ার্ড স্ল্যাশ (`/`) ব্যবহার না করলে:

যদি আপনি **`cp`** কমান্ডে **`mydir2`** এর পরে ফরওয়ার্ড স্ল্যাশ না দেন, তবে কমান্ডটি তখন **`mydir2`** কে একটি ফাইল হিসেবে ধারণ করতে পারে, এবং যদি `mydir2` আগে থেকে একটি ডিরেক্টরি না থাকে, এটি কেবল একটি ফাইলের নাম হিসেবে গণ্য হবে।

### Example:

1. **ফরওয়ার্ড স্ল্যাশ সহ:**

```shell
	cp -r mydir mydir2/
```
    
- এখানে `mydir2/` এর মানে হলো **`mydir2` একটি ডিরেক্টরি**। যদি **`mydir2`** ডিরেক্টরি না থাকে, এটি নতুন একটি ডিরেক্টরি তৈরি করবে এবং তার মধ্যে **`mydir`** কপি করবে।

2. **ফরওয়ার্ড স্ল্যাশ ছাড়া:**

    
```shell
	cp -r mydir mydir2
```
    
- যদি **`mydir2`** আগে থেকে একটি ডিরেক্টরি থাকে, এটি **`mydir`** ডিরেক্টরিটিকে **`mydir2/mydir`** নামক একটি নতুন সাবডিরেক্টরিতে কপি করবে।
    - যদি **`mydir2`** একটি ফাইল হয়, এটি ত্রুটি দেখাবে, কারণ `cp` ডিরেক্টরি কপি করতে চাইলে **`/`** আশা করবে, এবং ফাইল কপি করার সময়ও এটি **ফাইলের নাম** হিসেবে ব্যবহার করবে, ডিরেক্টরি নয়।

### উপসংহার:

- **ফরওয়ার্ড স্ল্যাশ (/) দিয়ে**, আপনি ডিরেক্টরি নির্দিষ্ট করছেন এবং নিশ্চিত করছেন যে কন্টেন্ট সেই ডিরেক্টরিতে কপি হবে।
- **ফরওয়ার্ড স্ল্যাশ ছাড়া**, **`cp`** প্রোগ্রামটি একটি ফাইল হিসেবে ভাবতে পারে বা ডিরেক্টরি হিসেবে কপি করার সময় সাবডিরেক্টরি তৈরি করতে পারে, বিশেষত যদি গন্তব্য ডিরেক্টরি না থাকে।
    
20. `temp` ডিরেক্টরির কন্টেন্ট দেখান।
    
```shell
	ls -l temp/
```

21. `temp` ডিরেক্টরির নাম পরিবর্তন করুন।
    
```shell
	mv temp temp2
```
    
22. বর্তমান ওয়ার্কিং ডিরেক্টরিতে ফাইলের ধরন দেখান।

```shell
	ls -F
```
    
23. `temp2` ডিরেক্টরির সকল ফাইল পুনরাবৃত্তিমূলকভাবে নতুন ডিরেক্টরি `temp3`-এ কপি করুন।

```shell
	cp -R temp2 temp3
```
    
24. বর্তমান ওয়ার্কিং ডিরেক্টরি থেকে শুরু করে সমস্ত ফাইলের তালিকা পুনরাবৃত্তিমূলকভাবে দেখান।
 
```shell
	ls -R
```

`ls -R` কমান্ডটি লিনাক্সে **ফাইল এবং ডিরেক্টরি গুলি রিকার্সিভভাবে** তালিকা করতে ব্যবহৃত হয়। এর মানে হল, এটি বর্তমান ডিরেক্টরির কন্টেন্ট দেখানোর পর, যেকোনো সাবডিরেক্টরির কন্টেন্টও দেখাবে, এবং সাবডিরেক্টরির ভিতরে আরো কোনো সাবডিরেক্টরি থাকলে তার কন্টেন্টও দেখাবে, এইভাবে পুরো ডিরেক্টরি স্ট্রাকচারটি প্রদর্শিত হবে।

এখানে ব্যাখ্যা:

- **`ls`**: বর্তমান ডিরেক্টরির ফাইল এবং ডিরেক্টরি তালিকা করে।
- **`-R`**: এর মানে হল **রিকার্সিভ**, অর্থাৎ সাবডিরেক্টরিগুলোর কন্টেন্টও দেখাবে।

### উদাহরণ:

ধরা যাক, আপনার ডিরেক্টরি স্ট্রাকচার কিছু এই রকম:

```plaintext
/home/user
├── file1.txt
├── file2.txt
└── folder1
    ├── file3.txt
    └── folder2
        └── file4.txt
```


যখন আপনি `ls -R` কমান্ডটি চালাবেন, তখন এটি এই রকম কিছু আউটপুট দেবে:
```shell

.: 
file1.txt  file2.txt  folder1  

./folder1:
file3.txt  folder2  

./folder1/folder2:
file4.txt
```

এখানে, এটি বর্তমান ডিরেক্টরি এবং এর সব সাবডিরেক্টরির মধ্যে থাকা ফাইলগুলো রিকার্সিভভাবে দেখাচ্ছে।

1. একটি নতুন `temp` ডিরেক্টরি তৈরি করুন।

```shell
	mkdir temp
```
    
26. `alpha` নামে একটি নতুন খালি ফাইল তৈরি করুন।
    
```shell
	touch alpha
```
    
27. বর্তমান ডিরেক্টরির কন্টেন্ট দেখান।
    
```shell
	ls
```
    
28. `alpha` ফাইল মুছে ফেলুন।
 
```shell
	rm alpha
```
    
29. `temp` ডিরেক্টরি মুছে ফেলুন।
  
```shell
	rmdir temp
```
    
30. বর্তমান ডিরেক্টরিতে ফাইলের ধরন দেখান।
    
```shell
	ls -F
```
    
31. আপনার হোম ডিরেক্টরি থেকে `myfile` নামে সমস্ত ফাইল অনুসন্ধান করুন।
    
```shell
	find ~ -name myfile
```
    
32. আপনার হোম ডিরেক্টরি থেকে `temp2` নামে সমস্ত ফাইল অনুসন্ধান করুন।
  
```shell
	find ~ -name temp2
```
## Vim টেক্সট এডিটর দিয়ে ফাইল এডিট করুন

Vim হলো Oracle Linux-এর ডিফল্ট এডিটর, যেখানে ব্যবহারকারীরা শুধুমাত্র কীবোর্ড ব্যবহার করে কন্ট্রোল করেন, মেনু বা মাউসের প্রয়োজন হয় না।

1. হোম ডিরেক্টরি থেকে `vim` কমান্ড টাইপ করুন।
    
    ```shell
    vim
    ```

2. _ইনসার্ট মোডে_ প্রবেশ করতে `i` কী চাপুন এবং নিচের টেক্সট লিখুন।
    
    ```text
    Hello World
    What is your
    Waht id today's date?
    ```

3. `What is your` লাইনে টেক্সট যোগ করুন।
    
    - _নরমাল মোডে_ যেতে `Esc` কী চাপুন।
    - লাইনটির শেষ ক্যারেক্টারে যাওয়ার জন্য `h`, `j`, `k`, `l` অথবা অ্যারো কী ব্যবহার করুন।
    - `a` কী চাপুন এবং একটি স্পেস দিয়ে `_name?_` লিখুন।

4. `Waht id today’s date?` লাইনের `d` ক্যারেক্টারটি `s` দিয়ে পরিবর্তন করুন।
    
    - _নরমাল মোডে_ ফিরে যেতে `Esc` চাপুন।
    - `j` বা ডাউন অ্যারো কী চাপুন লাইনটিতে যেতে।
    - `h` বা বাম অ্যারো কী চাপুন ক্যারেক্টারে যেতে।
    - `d` ক্যারেক্টারে কার্সর নিয়ে যান এবং `r` কী চাপুন। এখন `d` এর পরিবর্তে `s` টাইপ করুন।

5. `Waht` শব্দটিকে `What` এ পরিবর্তন করুন।
    
    - `Esc` চাপুন এবং কার্সরটি `Waht`-এর ওপর নিয়ে যান।
    - `a` ক্যারেক্টারে কার্সর রেখে `cw` টাইপ করুন।
    - `hat` লিখে পরিবর্তন সম্পন্ন করুন এবং `Esc` চাপুন।

6. `Hello World` লাইনটি কপি এবং পেস্ট করুন।
    
    - _নরমাল মোডে_ ফিরে যেতে `Esc` চাপুন।
    - `Hello World` লাইনের শুরুতে কার্সর নিন।
    - `yy` টাইপ করে কপি করুন এবং `p` চাপুন পেস্ট করার জন্য।

7. অতিরিক্ত `Hello World` লাইনটি মুছে ফেলুন।
    
    - _কমান্ড মোডে_ ফিরে যেতে `Esc` চাপুন।
    - কার্সর অতিরিক্ত লাইনে নিয়ে যান এবং `dd` চাপুন।

8. `What` শব্দটি খুঁজুন।
    
    - _কমান্ড মোডে_ যেতে `Esc` চাপুন।
    - `/` কী চাপুন এবং `What` লিখে `Enter` চাপুন।

9. পরবর্তী `What` শব্দটি খুঁজুন।
    
    - `n` কী চাপুন। কার্সর পরবর্তী মিলে যাওয়া স্থানে যাবে।

10. লাইন নম্বর দেখান।
    
    - _কমান্ড মোডে_ ফিরে যেতে `Esc` চাপুন।
    - `:set nu` টাইপ করে `Enter` চাপুন।

11. লাইন নম্বর সরান।
    
    - _কমান্ড মোডে_ ফিরে যেতে `Esc` চাপুন।
    - `:set nonu` টাইপ করে `Enter` চাপুন।

12. ফাইলটি সেভ এবং প্রস্থান করুন।
    
    - _কমান্ড মোডে_ ফিরে যেতে `Esc` চাপুন।
    - `:w intro.txt` লিখে `Enter` চাপুন।
    - `:q` লিখে প্রস্থান করুন।
## ফাইল অনুমতি সম্পর্কে জানুন

Oracle Linux-এ ফাইল অনুমতি ফাইল ও ডিরেক্টরির অ্যাক্সেস নিয়ন্ত্রণ এবং সেগুলোর ডেটা সুরক্ষার জন্য অত্যন্ত গুরুত্বপূর্ণ।

1. নিশ্চিত করুন যে আপনি আপনার হোম ডিরেক্টরিতে আছেন।
    
    ```shell
    cd ~
    ```

2. বিদ্যমান ডিরেক্টরির মালিক খুঁজে বের করুন।
    
    ```shell
    ls -ld
    ```
    
    আউটপুটের তৃতীয় কলামে ডিরেক্টরির মালিক দেখানো হবে।

3. `temp2` ডিরেক্টরির কন্টেন্টের মালিক নির্ধারণ করুন।
    
    ```shell
    ls -l temp2
    ```

4. `temp2` ডিরেক্টরির মালিকানা root ইউজারে পরিবর্তন করুন।
    
    - `sudo su` কমান্ড ব্যবহার করে root ইউজারে যান।
    - মালিকানা পরিবর্তন কমান্ড চালান।
    
    ```shell
    sudo su
    chown root temp2
    ```

5. `temp2` ডিরেক্টরির মালিকানার পরিবর্তন নিশ্চিত করুন।
    
    ```shell
    ls -l
    ```

6. এর কন্টেন্টের মালিকানা root এবং group-কে root-এ রিকার্সিভলি পরিবর্তন করুন।
    
    ```shell
    chown -R root:root temp2  
    ls -lR temp2  
    ```

7. `su` মোড থেকে বেরিয়ে আসুন।
    
    ```shell
    exit
    ```
### ব্যবহারের কারণ:

1. **শেল সেশন শেষ করা**: টার্মিনাল কাজ শেষ করে বের হতে `exit` কমান্ড ব্যবহার করা হয়, যা শেল সেশন বন্ধ করে বা লগ আউট করে।
2. **স্ক্রিপ্ট থেকে বের হওয়া**: স্ক্রিপ্টের কার্যক্রম শেষ করতে বা কোনো ত্রুটির কারণে স্ক্রিপ্ট থামাতে `exit` ব্যবহার হয়। আপনি **exit status** দিয়ে ফলাফল নির্দেশ করতে পারেন:
    - `exit 0` = সফলতা
    - `exit 1` = ত্রুটি
3. **স্ক্রিপ্টের প্রবাহ নিয়ন্ত্রণ**: `exit` দিয়ে স্ক্রিপ্ট থামিয়ে পরবর্তী কমান্ড চালানো থেকে বিরত রাখা যায়।

### উদাহরণ:

- **শেল সেশন শেষ করা**:
   
```shell
$ exit
```
    
- **স্ক্রিপ্ট থেকে সফলভাবে বের হওয়া**:
 
```shell
		#!/bin/bash
		echo "এটি একটি সফল মেসেজ"
		exit 0
```
    
- **স্ক্রিপ্ট থেকে ত্রুটির সঙ্গে বের হওয়া**:

```shell
		#!/bin/bash 
		echo "ত্রুটি ঘটেছে"
		exit 1
```
    

### সারাংশ:

`exit` কমান্ডটি শেল সেশন বা স্ক্রিপ্টের কার্যক্রম শেষ করতে এবং প্রক্রিয়া নিয়ন্ত্রণে গুরুত্বপূর্ণ, স্ট্যাটাস কোড ফেরত দিয়ে সফলতা বা ত্রুটি জানানোর কাজ করে।

8. নিশ্চিত করুন যে আপনার সিস্টেমে `umask` মান 0022 সেট করা আছে।
    
    ```shell
    umask
    ```

9. যদি `umask` মান 0022 না হয়, তাহলে সেট করুন।
    
    ```shell
    umask 0022
    ```

10. `temp3` ডিরেক্টরিতে একটি নতুন `perm` ডিরেক্টরি তৈরি করুন।
    
    ```shell
    mkdir temp3/perm
    ```

11. `/etc` ডিরেক্টরিতে যান এবং নিচের চারটি ফাইল তালিকাভুক্ত করুন: `group`, `motd`, `shadow`, এবং `fstab`।
    
    ```shell
    cd /etc  
    ls -l group motd shadow fstab
    ```

    > **বিঃদ্রঃ:** Oracle Linux-এ `shadow` ফাইলের উপর অনুমতি নেই।

12. এই চারটি ফাইল `~/temp3/perm` ডিরেক্টরিতে কপি করুন। `shadow` ফাইল কপি করতে ব্যর্থ হবে।
    
    ```shell
    cp group motd shadow fstab ~/temp3/perm
    ```

    > **উদাহরণ আউটপুট:**
    > 
    ```text
    > cp: cannot open ’shadow’ for reading: Permission denied
    > ```

13. `temp3` ডিরেক্টরিতে যান এবং এর `~/temp3/perm` ডিরেক্টরির কন্টেন্ট যাচাই করুন।
    
    ```shell
    cd ~/temp3
    ls -l perm
    ```

14. আপনার হোম ডিরেক্টরিতে ফিরে যান।
    
    ```shell
    cd ~
    ```

## ফাইল এবং ডিরেক্টরি অনুমতি পরিচালনা করুন

### নতুন ডিরেক্টরি ও ফাইল তৈরি করুন

15. `test` নামে একটি নতুন ডিরেক্টরি এবং তার মধ্যে `test1` নামে একটি নতুন ফাইল তৈরি করুন।  
    ```shell
    mkdir test
    touch test/test1
    ```

[  ছুঁয়ে দিলে মন  ](https://www.youtube.com/watch?v=LyQi3OLB_Ek)
### কেন `touch` নামকরণ?

- ফাইলের **টাইমস্ট্যাম্প** বা **প্রাথমিক কনটেন্ট** পরিবর্তন করার মাধ্যমে এটি ফাইলকে "স্পর্শ" (touch) করার মতো আচরণ করে, তাই এটি এই নাম পেয়েছে।
- এটি একধরনের দ্রুত কাজ ছিল যা কমান্ড লাইনে টাইমস্ট্যাম্প পরিবর্তন বা ফাইল তৈরি করতে সাহায্য করত, যেটি অন্যান্য কমান্ডের চেয়ে দ্রুত ছিল।


### `touch` কমান্ডের নামকরণের কারণ:

- **"touch"** শব্দটির মানে "স্পর্শ" বা "ছোঁয়া" (যেমন আপনি একটি ফাইলের সাথে সংযোগ বা স্পর্শ করছেন)।
- ঐতিহাসিকভাবে, ইউনিক্স সিস্টেমে **`touch`** কমান্ডটি এমন একটি কাজের জন্য তৈরি করা হয়েছিল যা ফাইলের **টাইমস্ট্যাম্প** পরিবর্তন করত, এবং ব্যবহারকারীরা ফাইলটি "স্পর্শ" করার মাধ্যমে তার অবস্থান পরিবর্তন করতে পারত, যদিও এর ভিতরে কোনো কনটেন্ট না থাকলেও।

**`touch`** কমান্ডটি **লিনাক্স** এবং অন্যান্য ইউনিক্স ভিত্তিক সিস্টেমে একটি সাধারণ টুল, এবং এর নামকরণ এবং উদ্দেশ্য সম্পর্কে কিছু বিশেষ কারণ রয়েছে।

### `touch` কমান্ডের উদ্দেশ্য:

- **ফাইল তৈরি করা**: `touch` মূলত একটি খালি ফাইল তৈরি করতে ব্যবহৃত হয়, যদি সেই ফাইলটি পূর্বে উপস্থিত না থাকে।
- **ফাইলের টাইমস্ট্যাম্প পরিবর্তন করা**: যদি ফাইলটি আগে থেকেই থাকে, তবে এটি **ফাইলের এক্সেস** (access) এবং **মডিফিকেশন** টাইমস্ট্যাম্প আপডেট করে।

### উদাহরণ:

- **নতুন ফাইল তৈরি করা**: `touch newfile.txt`
- **ফাইলের টাইমস্ট্যাম্প আপডেট করা**: যদি `newfile.txt` আগে থেকেই থাকে, তবে এটি শুধুমাত্র তার **অন্তর্বর্তী সময়** (modification time) আপডেট করবে।




16. নতুন ফাইল `test1`-এর ডিফল্ট অনুমতি যাচাই করুন।  
    ```shell
    ls –l test/test1
    ```

17. নতুন ডিরেক্টরি `test`-এর ডিফল্ট অনুমতি যাচাই করুন।  
    ```shell
    ls –ld test
    ```

### ফাইল অনুমতি পরিবর্তন

18. প্রতীকী মোড ব্যবহার করে `motd` ফাইলের জন্য গ্রুপে লেখার (w) অনুমতি যোগ করুন।  
    ```shell
    chmod g+w temp3/perm/motd
    ls -l temp3/perm
    ```
    > **প্রতীকী মোড:** ব্যবহারকারীর ধরণ এবং অনুমতির জন্য অক্ষর ও চিহ্ন ব্যবহার করে।

19. অক্টাল মোড ব্যবহার করে `motd` ফাইলের অনুমতি `-rwxrw----` এ পরিবর্তন করুন।  
    ```shell
    chmod 760 temp3/perm/motd
    ls -l temp3/perm
    ```
    > **অক্টাল মোড:** ৮ ভিত্তিক সংখ্যা ব্যবহার করে অনুমতি সেট করে (০-৭ পর্যন্ত)।

20. `group` ফাইলের জন্য `other`-এর জন্য লেখার (w) অনুমতি যোগ করুন।  
    ```shell
    chmod 646 temp3/perm/group
    ls -l temp3/perm
    ```

21. `motd` ফাইলের UID এবং GID সনাক্ত করুন।  
    ```shell
    ls -n temp3/perm/motd
    ```

### নতুন নোটস ডিরেক্টরি এবং মেমো ফাইল তৈরি করুন

22. `notes` নামে একটি নতুন ডিরেক্টরি তৈরি করুন।  
    ```shell
    mkdir notes
    ```

23. `notes` ডিরেক্টরিতে একটি নতুন `memo` ফাইল তৈরি করুন।  
    ```shell
    touch notes/memo
    ls -l notes/memo
    ```

24. প্রতীকী মোড ব্যবহার করে `memo` ফাইল থেকে মালিকের জন্য পড়ার (r) অনুমতি সরান।  
    ```shell
    chmod u-r notes/memo
    ls -l notes/memo
    ```

25. `memo` ফাইলের বিষয়বস্তু দেখুন।  
    ```shell
    cat notes/memo
    ```
    > **ফলাফল:** ব্যবহারকারীর অনুমতি না থাকায় এই কমান্ডটি ব্যর্থ হবে।

---

## সিস্টেম প্রসেস পর্যবেক্ষণ করুন

### প্রসেস পর্যবেক্ষণ এবং নিয়ন্ত্রণ

1. সিস্টেমে বর্তমানে চলমান প্রসেসগুলোর তালিকা দেখুন।  
    ```shell
    ps
    ```

## সিস্টেম প্রসেস ম্যানেজমেন্ট

### প্রসেস তালিকা এবং মনিটরিং

1. **আপনার সিস্টেমে বর্তমানে চলমান প্রসেসগুলি তালিকাভুক্ত করুন:**  
    ```shell
    ps
    ```

2. **বর্তমানে চলমান প্রসেসগুলির একটি বিস্তারিত তালিকা প্রিন্ট করুন:**  
    ```shell
    ps -f
    ```

3. **প্রত্যেকটি প্রসেসের তথ্য দেখান এবং মোট প্রসেসের সংখ্যা গণনা করুন:**  
    ```shell
    ps -e  
    ps -e | wc -l
    ```

4. **`ps` কমান্ড চালান এবং TTY কলামে `pts/0` যা কন্ট্রোলিং টার্মিনাল তা লক্ষ্য করুন:**  
    ```shell
    ps -f
    ```

5. **দ্বিতীয় টার্মিনাল খুলুন এবং SSH এর মাধ্যমে ইনস্ট্যান্সে সংযোগ করুন:**  
    ```shell
    ssh oracle@<ip_address_of_instance>
    ```

6. **নতুন টার্মিনালে `ps` কমান্ড চালান এবং TTY কলামে `pts/1` লক্ষ্য করুন:**  
    ```shell
    ps -f
    ```

---

### টার্মিনালগুলির মধ্যে প্রসেস ইন্টারঅ্যাকশন

7. **আপনার প্রথম টার্মিনালে একটি `sleep` প্রসেস চালু করুন:**  
    ```shell
    sleep 100
    ```

8. **দ্বিতীয় টার্মিনালে `sleep` প্রসেসের PID শনাক্ত করুন:**  
    ```shell
    ps -ef | grep sleep
    ```

9. **দ্বিতীয় টার্মিনাল থেকে `sleep` প্রসেসটি বন্ধ করুন:**  
    `<PID>` এর স্থানে প্রকৃত PID দিন।  
    ```shell
    kill <PID>
    ```

10. **দ্বিতীয় টার্মিনালের টার্মিনাল নাম শনাক্ত করতে `tty` কমান্ড ব্যবহার করুন:**  
    ```shell
    tty
    ```
    আউটপুট হবে `/dev/pts/1` এর মতো কিছু।

11. **আপনার প্রথম টার্মিনালে ফিরে আসুন।**

12. **দ্বিতীয় টার্মিনাল উইন্ডোর সাথে সম্পর্কিত PID খুঁজে বের করুন:**  
    ```shell
    pgrep -t pts/1
    ```

13. **SSH সেশন বন্ধ করতে এবং দ্বিতীয় টার্মিনাল থেকে লগ আউট করতে `kill` কমান্ড ব্যবহার করুন:**  
    `<PID>` এর স্থানে SSH সেশনের PID দিন।  
    ```shell
    kill <PID>
    ```

---

### সিগন্যাল ম্যানেজমেন্ট

14. **`kill -l` কমান্ড ব্যবহার করে সিগন্যালের নাম এবং মান শনাক্ত করুন:**  
    ```shell
    kill -l 9  
    kill -l kill  
    kill -l 15  
    kill -l term
    ```
    - **সিগন্যাল মান 9:** KILL  
    - **সিগন্যাল নাম kill:** 9  
    - **সিগন্যাল মান 15:** TERM  
    - **সিগন্যাল নাম term:** 15  

---

### ব্যাকগ্রাউন্ড প্রসেস

15. **`sleep` কমান্ড চালান এবং এটি ব্যাকগ্রাউন্ডে স্থানান্তরিত করুন:**  
    ```shell
    sleep 600 &
    ```

## সিস্টেম প্রসেস ম্যানেজমেন্ট (ক্রমাগত)

### প্রসেসের বিস্তারিত

16. **`ps` কমান্ড ব্যবহার করে ঐ টার্মিনাল উইন্ডোতে চলমান bash শেল প্রসেস শনাক্ত করুন:**  
    ```shell
    ps
    ```

17. **দ্বিতীয় টার্মিনাল উইন্ডোতে SSH এর মাধ্যমে ol-node-01 সিস্টেমে সংযোগ করুন:**  
    ```shell
    ssh oracle@<ip_address_of_instance>
    ```

18. **দ্বিতীয় টার্মিনাল উইন্ডোতে প্রসেস ট্রি প্রদর্শন করুন এবং প্রথম টার্মিনাল উইন্ডোতে চলমান `sleep` প্রসেসের PID আর্গুমেন্ট হিসেবে প্রদান করুন, `pstree -p <PID>` কমান্ড ব্যবহার করে:**  
    - এই উদাহরণে PID হল 1252।  
    - আপনার PID কমান্ডে প্রদত্ত PID থেকে আলাদা হতে পারে।  
    ```shell
    pstree -p 1252
    ```

19. **দ্বিতীয় টার্মিনাল উইন্ডোতে প্রথম টার্মিনাল উইন্ডোটি বন্ধ করতে `kill` কমান্ড ব্যবহার করুন bash শেল PID সহ:**  
    ```shell
    kill -9 1252
    ```

20. **প্রথম টার্মিনাল উইন্ডোতে `ps` কমান্ড চালান এবং লক্ষ্য করুন যে `sleep 600` প্রসেসটি চলে গেছে:**  
    ```shell
    ps
    ```


## User in Oracle Linux: 

 ###  **লিনাক্সে** `su - bob` **কমান্ডের ব্যবহার বুঝে নিন**
 
**`su - bob`** কমান্ডটি লিনাক্সে **bob** ব্যবহারকারীর অ্যাকাউন্টে সুইচ করার জন্য ব্যবহৃত হয়। এর মানে:

1. **`su`**: এর পুরো রূপ **"substitute user"** বা **"switch user"**।
	1. এটি আপনাকে অন্য কোনো ব্যবহারকারীর অ্যাকাউন্টে সুইচ করতে সাহায্য করে।
	2. ডিফল্টভাবে, যদি কোনো ব্যবহারকারীর নাম না দেওয়া হয়, তাহলে এটি **root** ব্যবহারকারীতে সুইচ করবে।
    
2. **`-`**: ড্যাশ বা হাইফেনটি **`su`** কমান্ডের পর ব্যবহৃত হয় যাতে সম্পূর্ণ লগইন সেশন সিমুলেট করা যায়।
	1. এর মানে হলো, যখন আপনি **bob** ব্যবহারকারীতে সুইচ করবেন, তখন সিস্টেম **bob** এর **হোম ডিরেক্টরি**, **শেল**, এবং **এনভায়রনমেন্ট ভেরিয়েবল** লোড করবে।
		1. এটি নিশ্চিত করে যে আপনি **bob** এর সম্পূর্ণ পরিবেশে প্রবেশ করছেন।
    
3. **`bob`**: যেই ব্যবহারকারীর অ্যাকাউন্টে আপনি সুইচ করতে চান, তার নাম।
    

#### কি হয়: `su - bob`

- **`su - bob`**: এই কমান্ডটি **bob** ব্যবহারকারীতে সুইচ করবে এবং আপনাকে **bob** এর হোম ডিরেক্টরিতে নিয়ে যাবে, যেখানে **bob** এর শেল এবং অন্যান্য পরিবেশ সেট করা থাকবে। এর জন্য আপনাকে **bob** এর পাসওয়ার্ড প্রবেশ করতে হবে (যদি আপনি root না হন)।

#### উদাহরণ:

যদি আপনি সাধারণ ব্যবহারকারী হিসেবে লগ ইন করেন এবং **bob** এ সুইচ করতে চান, তাহলে আপনি কমান্ডটি লিখবেন:

```shell
su - bob
```

তারপর **bob** এর পাসওয়ার্ড প্রবেশ করলে আপনি **bob** এর পরিবেশে লগ ইন হয়ে যাবেন এবং **bob** হিসেবে কমান্ড রান করতে পারবেন।

#### সারাংশ:

- **`su`**: অন্য কোনো ব্যবহারকারীতে সুইচ করার জন্য ব্যবহৃত।
- **`-`**: পুরো লগইন পরিবেশ (হোম ডিরেক্টরি, শেল, ইত্যাদি) লোড করে।
- **`bob`**: যেই ব্যবহারকারীর অ্যাকাউন্টে আপনি সুইচ করতে চান।

যদি আপনি **root** হিসেবে লগ ইন না হন, তাহলে **`su - bob`** কমান্ডটি চালানোর জন্য আপনাকে **sudo** প্রিভিলেজ প্রয়োজন হবে।


## Group in Oracle Linux

### **`getent`**  কমান্ডটি লিনাক্সে  ব্যবহৃত হয় 

**`getent`** কমান্ডটি লিনাক্সে ব্যবহৃত একটি কমান্ড, যা সিস্টেমের তথ্য ফাইল বা ডাটাবেসের কন্টেন্ট দেখতে সাহায্য করে। এর পূর্ণরূপ **"get entries"**। **`/etc/group`**, **`/etc/passwd`**, এবং **`/etc/shadow`** ফাইলগুলি এর উদাহরণ।

**`getent group`** কমান্ডের আউটপুট **`cat /etc/group`** কমান্ডের আউটপুট থেকে কিছুটা আলাদা হতে পারে, কারণ **`getent`** সিস্টেমের অন্যান্য ডাটাবেস যেমন LDAP থেকেও তথ্য আনে। এটি **`/etc/group`** ফাইলের বাইরেও গ্রুপ সম্পর্কিত তথ্য সংগ্রহ করে এবং প্রদর্শন করে।


### **`getent group`** কমান্ডের ব্যবহার:

1. **সকল গ্রুপের তালিকা দেখা**:
    
    - শুধু **`getent group`** লিখলে, এটি সিস্টেমে বিদ্যমান সমস্ত গ্রুপের নাম, GID (গ্রুপ আইডি), এবং গ্রুপের সদস্যদের একটি তালিকা দেখাবে।
    - উদাহরণ:
    
		```shell
		getent group
		```
        
    - এটি আপনার সিস্টেমের সমস্ত গ্রুপের তথ্য দেখাবে, যেমন:
```shell
			root:x:0: bob:x:1001:bob developers:x:1002:bob,alice
```
        
2. **নির্দিষ্ট গ্রুপের তথ্য দেখা**:
    
    - যদি আপনি কোনো নির্দিষ্ট গ্রুপের তথ্য দেখতে চান, তবে গ্রুপের নাম ব্যবহার করে কমান্ডটি চালান।
    - উদাহরণ:
    
```shell
		getent group developers
```
        
- এটি **developers** গ্রুপের বিস্তারিত তথ্য দেখাবে, যেমন:
    
```shell
		developers:x:1002:bob,alice
```
        
- এখানে `x` গ্রুপের পাসওয়ার্ড ক্ষেত্র (যদিও অধিকাংশ সিস্টেমে এটি খালি থাকে), `1002` গ্রুপের GID, এবং `bob,alice` গ্রুপের সদস্যদের নাম।

#### সারাংশ:

- **`getent`**: সিস্টেম ডাটাবেস থেকে তথ্য দেখার জন্য ব্যবহৃত হয়।
- **`getent group`**: **`/etc/group`** এবং অন্যান্য ডাটাবেস থেকে গ্রুপ সম্পর্কিত তথ্য দেখায়।

